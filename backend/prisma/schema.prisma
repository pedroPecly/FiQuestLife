generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String          @id @default(uuid())
  email                  String          @unique
  username               String          @unique
  name                   String
  password               String
  createdAt              DateTime        @default(now()) @map("created_at")
  updatedAt              DateTime        @updatedAt @map("updated_at")
  avatarUrl              String?         @map("avatar_url")
  bio                    String?
  coins                  Int             @default(0)
  currentStreak          Int             @default(0) @map("current_streak")
  dailyReminderTime      String?         @map("daily_reminder_time")
  lastActiveDate         DateTime?       @map("last_active_date")
  level                  Int             @default(1)
  longestStreak          Int             @default(0) @map("longest_streak")
  notificationsEnabled   Boolean         @default(true) @map("notifications_enabled")
  profilePublic          Boolean         @default(false) @map("profile_public")
  xp                     Int             @default(0)
  birthDate              DateTime        @map("birth_date")
  expoPushToken          String?         @map("expo_push_token")
  receivedFriendRequests FriendRequest[] @relation("ReceivedRequests")
  sentFriendRequests     FriendRequest[] @relation("SentRequests")
  friendshipsReceived    Friendship[]    @relation("FriendshipReceiver")
  friendshipsInitiated   Friendship[]    @relation("FriendshipInitiator")
  rewardHistory          RewardHistory[]
  userBadges             UserBadge[]
  userChallenges         UserChallenge[]
  activityLikes          ActivityLike[]
  activityComments       ActivityComment[]
  notifications          Notification[]

  @@map("users")
}

/// *
/// * Tabela de desafios (catálogo)
/// * 
/// * Exemplos:
/// * - "Beber 2L de água" (DAILY, HYDRATION, EASY)
/// * - "Ir à academia 3x na semana" (WEEKLY, PHYSICAL_ACTIVITY, HARD)
model Challenge {
  id             String              @id @default(uuid())
  title          String
  description    String
  category       ChallengeCategory
  difficulty     ChallengeDifficulty
  xpReward       Int                 @map("xp_reward")
  coinsReward    Int                 @map("coins_reward")
  isActive       Boolean             @default(true) @map("is_active")
  frequency      ChallengeFrequency  @default(DAILY)
  requiresPhoto  Boolean             @default(false) @map("requires_photo")
  createdAt      DateTime            @default(now()) @map("created_at")
  updatedAt      DateTime            @updatedAt @map("updated_at")
  userChallenges UserChallenge[]

  @@map("challenges")
}

/// *
/// * Relação N:N entre User e Challenge
/// * 
/// * Cada registro representa um desafio atribuído a um usuário.
/// * O mesmo usuário pode ter o mesmo desafio várias vezes
/// * (ex: "Beber 2L de água" todos os dias)
/// * 
/// * Por isso temos @@unique([userId, challengeId, assignedAt])
/// * - Garante que um usuário não tenha o mesmo desafio 2x no mesmo momento
/// * - Mas permite ter o mesmo desafio em dias diferentes
model UserChallenge {
  id          String          @id @default(uuid())
  userId      String          @map("user_id")
  challengeId String          @map("challenge_id")
  status      ChallengeStatus @default(PENDING)
  assignedAt  DateTime        @default(now()) @map("assigned_at")
  completedAt DateTime?       @map("completed_at")
  progress    Int             @default(0)
  notes       String?
  photoUrl    String?         @map("photo_url")
  caption     String?
  challenge   Challenge       @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, challengeId, assignedAt])
  @@index([userId, status])
  @@index([assignedAt])
  @@map("user_challenges")
}

/// *
/// * Catálogo de Badges (Emblemas)
/// * 
/// * Define todos os badges disponíveis no sistema.
/// * Exemplos:
/// * - "Primeiro Passo" (BEGINNER, completar primeiro desafio)
/// * - "Guerreiro Semanal" (CONSISTENCY, 7 dias de streak)
/// * - "Mestre da Hidratação" (ACHIEVEMENT, completar 100 desafios de hidratação)
model Badge {
  id               String               @id @default(uuid())
  name             String               @unique
  description      String
  imageUrl         String               @map("image_url")
  category         BadgeCategory
  rarity           BadgeRarity          @default(COMMON)
  requirementType  BadgeRequirementType @map("requirement_type")
  requirementValue Int                  @map("requirement_value")
  isActive         Boolean              @default(true) @map("is_active")
  createdAt        DateTime             @default(now()) @map("created_at")
  updatedAt        DateTime             @updatedAt @map("updated_at")
  order            Int                  @default(0)
  userBadges       UserBadge[]

  @@map("badges")
}

/// *
/// * Relação N:N entre User e Badge
/// * 
/// * Registra quais badges o usuário conquistou.
/// * Cada badge só pode ser conquistado uma vez por usuário.
model UserBadge {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  badgeId     String   @map("badge_id")
  earnedAt    DateTime @default(now()) @map("earned_at")
  isDisplayed Boolean  @default(false) @map("is_displayed")
  badge       Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@index([userId])
  @@index([earnedAt])
  @@map("user_badges")
}

/// *
/// * Histórico de Recompensas
/// * 
/// * Registra todas as recompensas recebidas por completar desafios,
/// * subir de nível, conquistar badges, etc.
/// * 
/// * Exemplos:
/// * - +50 XP por completar desafio
/// * - +20 moedas por completar desafio
/// * - Badge "Primeiro Passo" desbloqueado
model RewardHistory {
  id          String     @id @default(uuid())
  userId      String     @map("user_id")
  type        RewardType
  amount      Int
  source      String
  sourceId    String?    @map("source_id")
  description String?
  createdAt   DateTime   @default(now()) @map("created_at")
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("reward_history")
}

/// *
/// * Solicitações de Amizade
/// * 
/// * Registra todas as solicitações de amizade enviadas/recebidas.
/// * Uma solicitação pode estar PENDING, ACCEPTED, REJECTED ou BLOCKED.
/// * 
/// * Quando ACCEPTED, cria um registro em Friendship.
model FriendRequest {
  id         String           @id @default(uuid())
  senderId   String           @map("sender_id")
  receiverId String           @map("receiver_id")
  status     FriendshipStatus @default(PENDING)
  createdAt  DateTime         @default(now()) @map("created_at")
  updatedAt  DateTime         @updatedAt @map("updated_at")
  receiver   User             @relation("ReceivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User             @relation("SentRequests", fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([receiverId, status])
  @@index([senderId, status])
  @@map("friend_requests")
}

/// *
/// * Amizades Estabelecidas
/// * 
/// * Registra amizades confirmadas entre usuários.
/// * Criado apenas quando uma FriendRequest é ACCEPTED.
/// * 
/// * Permite rastrear atividades dos amigos, ranking conjunto, etc.
model Friendship {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  friendId  String   @map("friend_id")
  createdAt DateTime @default(now()) @map("created_at")
  friend    User     @relation("FriendshipReceiver", fields: [friendId], references: [id], onDelete: Cascade)
  user      User     @relation("FriendshipInitiator", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
  @@index([userId])
  @@index([friendId])
  @@map("friendships")
}

/// *
/// * Curtidas em atividades do feed
/// * Permite usuários curtirem conquistas de amigos
model ActivityLike {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  activityId String   @map("activity_id")
  createdAt  DateTime @default(now()) @map("created_at")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, activityId])
  @@index([activityId])
  @@index([userId])
  @@map("activity_likes")
}

/// *
/// * Comentários em atividades do feed
/// * Permite usuários comentarem em conquistas de amigos
model ActivityComment {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  activityId String   @map("activity_id")
  content    String
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([activityId])
  @@index([userId])
  @@map("activity_comments")
}

/// *
/// * Notificações do usuário
/// * Sistema de notificações in-app
model Notification {
  id         String           @id @default(uuid())
  userId     String           @map("user_id")
  type       NotificationType
  title      String
  message    String
  data       String?          @db.Text // JSON com dados extras
  read       Boolean          @default(false)
  createdAt  DateTime         @default(now()) @map("created_at")
  user       User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([createdAt])
  @@map("notifications")
}

/// *
/// * Categorias de desafios disponíveis
/// * Organiza os desafios por área da vida
enum ChallengeCategory {
  PHYSICAL_ACTIVITY
  NUTRITION
  HYDRATION
  MENTAL_HEALTH
  SLEEP
  SOCIAL
  PRODUCTIVITY
}

/// *
/// * Níveis de dificuldade dos desafios
/// * Determina XP e moedas ganhas
enum ChallengeDifficulty {
  EASY
  MEDIUM
  HARD
  EXPERT
}

/// *
/// * Frequência de repetição do desafio
/// * Define como o desafio se repete
enum ChallengeFrequency {
  DAILY
  WEEKLY
  MONTHLY
  ONE_TIME
}

/// *
/// * Status do desafio para o usuário
/// * Rastreia o progresso individual
enum ChallengeStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  SKIPPED
}

/// *
/// * Categorias de badges (emblemas)
/// * Define o tipo/tema do badge
enum BadgeCategory {
  BEGINNER
  CONSISTENCY
  MILESTONE
  SPECIAL
  SEASONAL
  ACHIEVEMENT
}

/// *
/// * Tipo de requisito para desbloquear badge
/// * Define qual condição deve ser cumprida
enum BadgeRequirementType {
  CHALLENGES_COMPLETED
  STREAK_DAYS
  LEVEL_REACHED
  XP_EARNED
  SPECIFIC_CHALLENGE
  CATEGORY_MASTER
  SOCIAL_INTERACTION
}

/// *
/// * Raridade do badge
/// * Determina o quão difícil é conseguir
enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

/// *
/// * Tipos de recompensas disponíveis
/// * Define o que o usuário ganha
enum RewardType {
  XP
  COINS
  BADGE
  ITEM
}

/// *
/// * Status de solicitação de amizade
/// * Define o estado atual da solicitação
enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
  BLOCKED
}

/// *
/// * Tipos de notificação
/// * Define o tipo de evento que gerou a notificação
enum NotificationType {
  FRIEND_REQUEST
  FRIEND_ACCEPTED
  ACTIVITY_LIKE
  ACTIVITY_COMMENT
  BADGE_EARNED
  LEVEL_UP
  CHALLENGE_COMPLETED
  STREAK_MILESTONE
}
