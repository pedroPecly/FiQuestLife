generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String          @id @default(uuid())
  email                  String          @unique
  username               String          @unique
  name                   String
  password               String
  createdAt              DateTime        @default(now()) @map("created_at")
  updatedAt              DateTime        @updatedAt @map("updated_at")
  avatarUrl              String?         @map("avatar_url")
  bio                    String?
  coins                  Int             @default(0)
  currentStreak          Int             @default(0) @map("current_streak")
  dailyReminderTime      String?         @map("daily_reminder_time")
  lastActiveDate         DateTime?       @map("last_active_date")
  level                  Int             @default(1)
  longestStreak          Int             @default(0) @map("longest_streak")
  notificationsEnabled   Boolean         @default(true) @map("notifications_enabled")
  profilePublic          Boolean         @default(false) @map("profile_public")
  xp                     Int             @default(0)
  birthDate              DateTime        @map("birth_date")
  expoPushToken          String?         @map("expo_push_token")
  receivedFriendRequests FriendRequest[] @relation("ReceivedRequests")
  sentFriendRequests     FriendRequest[] @relation("SentRequests")
  friendshipsReceived    Friendship[]    @relation("FriendshipReceiver")
  friendshipsInitiated   Friendship[]    @relation("FriendshipInitiator")
  rewardHistory          RewardHistory[]
  userBadges             UserBadge[]
  userChallenges         UserChallenge[]
  activityLikes          ActivityLike[]
  activityComments       ActivityComment[]
  sentChallengeInvites   ChallengeInvitation[] @relation("SentInvites")
  receivedChallengeInvites ChallengeInvitation[] @relation("ReceivedInvites")
  inventory              UserInventory[]
  purchases              Purchase[]
  activeBoosts           ActiveBoost[]

  @@map("users")
}

/// *
/// * Tabela de desafios (catálogo)
/// * 
/// * Exemplos:
/// * - "Beber 2L de água" (DAILY, HYDRATION, EASY)
/// * - "Ir à academia 3x na semana" (WEEKLY, PHYSICAL_ACTIVITY, HARD)
model Challenge {
  id             String              @id @default(uuid())
  title          String
  description    String
  category       ChallengeCategory
  difficulty     ChallengeDifficulty
  xpReward       Int                 @map("xp_reward")
  coinsReward    Int                 @map("coins_reward")
  isActive       Boolean             @default(true) @map("is_active")
  frequency      ChallengeFrequency  @default(DAILY)
  requiresPhoto  Boolean             @default(false) @map("requires_photo")
  autoVerifiable Boolean             @default(false) @map("auto_verifiable")
  verificationEvent String?          @map("verification_event")
  createdAt      DateTime            @default(now()) @map("created_at")
  updatedAt      DateTime            @updatedAt @map("updated_at")
  userChallenges UserChallenge[]
  challengeInvitations ChallengeInvitation[]

  @@map("challenges")
}

/// *
/// * Relação N:N entre User e Challenge
/// * 
/// * Cada registro representa um desafio atribuído a um usuário.
/// * O mesmo usuário pode ter o mesmo desafio várias vezes
/// * (ex: "Beber 2L de água" todos os dias)
/// * 
/// * Por isso temos @@unique([userId, challengeId, assignedAt])
/// * - Garante que um usuário não tenha o mesmo desafio 2x no mesmo momento
/// * - Mas permite ter o mesmo desafio em dias diferentes
model UserChallenge {
  id          String          @id @default(uuid())
  userId      String          @map("user_id")
  challengeId String          @map("challenge_id")
  status      ChallengeStatus @default(PENDING)
  assignedAt  DateTime        @default(now()) @map("assigned_at")
  completedAt DateTime?       @map("completed_at")
  progress    Int             @default(0)
  notes       String?
  photoUrl    String?         @map("photo_url")
  caption     String?
  challenge   Challenge       @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  challengeInvitation ChallengeInvitation?

  @@unique([userId, challengeId, assignedAt])
  @@index([userId, status])
  @@index([assignedAt])
  @@map("user_challenges")
}

/// *
/// * Catálogo de Badges (Emblemas)
/// * 
/// * Define todos os badges disponíveis no sistema.
/// * Exemplos:
/// * - "Primeiro Passo" (BEGINNER, completar primeiro desafio)
/// * - "Guerreiro Semanal" (CONSISTENCY, 7 dias de streak)
/// * - "Mestre da Hidratação" (ACHIEVEMENT, completar 100 desafios de hidratação)
model Badge {
  id               String               @id @default(uuid())
  name             String               @unique
  description      String
  imageUrl         String?              @map("image_url")
  category         BadgeCategory
  rarity           BadgeRarity          @default(COMMON)
  requirementType  BadgeRequirementType @map("requirement_type")
  requirementValue Int                  @map("requirement_value")
  requiredCount    Int?                 @map("required_count")
  event            String?
  requirement      String?
  icon             String?
  xpReward         Int                  @default(0) @map("xp_reward")
  coinsReward      Int                  @default(0) @map("coins_reward")
  isActive         Boolean              @default(true) @map("is_active")
  createdAt        DateTime             @default(now()) @map("created_at")
  updatedAt        DateTime             @updatedAt @map("updated_at")
  order            Int                  @default(0)
  userBadges       UserBadge[]

  @@map("badges")
}

/// *
/// * Relação N:N entre User e Badge
/// * 
/// * Registra quais badges o usuário conquistou.
/// * Cada badge só pode ser conquistado uma vez por usuário.
model UserBadge {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  badgeId     String   @map("badge_id")
  earnedAt    DateTime @default(now()) @map("earned_at")
  isDisplayed Boolean  @default(false) @map("is_displayed")
  badge       Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@index([userId])
  @@index([earnedAt])
  @@map("user_badges")
}

/// *
/// * Histórico de Recompensas
/// * 
/// * Registra todas as recompensas recebidas por completar desafios,
/// * subir de nível, conquistar badges, etc.
/// * 
/// * Exemplos:
/// * - +50 XP por completar desafio
/// * - +20 moedas por completar desafio
/// * - Badge "Primeiro Passo" desbloqueado
model RewardHistory {
  id          String     @id @default(uuid())
  userId      String     @map("user_id")
  type        RewardType
  amount      Int
  source      String
  sourceId    String?    @map("source_id")
  description String?
  createdAt   DateTime   @default(now()) @map("created_at")
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("reward_history")
}

/// *
/// * Solicitações de Amizade
/// * 
/// * Registra todas as solicitações de amizade enviadas/recebidas.
/// * Uma solicitação pode estar PENDING, ACCEPTED, REJECTED ou BLOCKED.
/// * 
/// * Quando ACCEPTED, cria um registro em Friendship.
model FriendRequest {
  id         String           @id @default(uuid())
  senderId   String           @map("sender_id")
  receiverId String           @map("receiver_id")
  status     FriendshipStatus @default(PENDING)
  createdAt  DateTime         @default(now()) @map("created_at")
  updatedAt  DateTime         @updatedAt @map("updated_at")
  receiver   User             @relation("ReceivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User             @relation("SentRequests", fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([receiverId, status])
  @@index([senderId, status])
  @@map("friend_requests")
}

/// *
/// * Amizades Estabelecidas
/// * 
/// * Registra amizades confirmadas entre usuários.
/// * Criado apenas quando uma FriendRequest é ACCEPTED.
/// * 
/// * Permite rastrear atividades dos amigos, ranking conjunto, etc.
model Friendship {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  friendId  String   @map("friend_id")
  createdAt DateTime @default(now()) @map("created_at")
  friend    User     @relation("FriendshipReceiver", fields: [friendId], references: [id], onDelete: Cascade)
  user      User     @relation("FriendshipInitiator", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
  @@index([userId])
  @@index([friendId])
  @@map("friendships")
}

/// *
/// * Curtidas em atividades do feed
/// * Permite usuários curtirem conquistas de amigos
model ActivityLike {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  activityId String   @map("activity_id")
  createdAt  DateTime @default(now()) @map("created_at")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, activityId])
  @@index([activityId])
  @@index([userId])
  @@map("activity_likes")
}

/// *
/// * Comentários em atividades do feed
/// * Permite usuários comentarem em conquistas de amigos
model ActivityComment {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  activityId String   @map("activity_id")
  content    String
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([activityId])
  @@index([userId])
  @@map("activity_comments")
}

/// *
/// * Convites de Desafios Entre Amigos
/// * 
/// * Permite que usuários desafiem amigos em desafios específicos.
/// * O amigo recebe notificação e o desafio aparece marcado como "Desafiado por X".
/// * Se o amigo já tem o desafio, vincula ao existente. Se não, cria um novo como extra.
model ChallengeInvitation {
  id              String                    @id @default(uuid())
  fromUserId      String                    @map("from_user_id")
  toUserId        String                    @map("to_user_id")
  challengeId     String                    @map("challenge_id")
  userChallengeId String?                   @unique @map("user_challenge_id")
  date            DateTime                  @default(now())
  status          ChallengeInvitationStatus @default(PENDING)
  message         String?
  expiresAt       DateTime                  @map("expires_at") // Convite expira em 24h ou quando o desafio do remetente expirar
  createdAt       DateTime                  @default(now()) @map("created_at")
  updatedAt       DateTime                  @updatedAt @map("updated_at")
  fromUser        User                      @relation("SentInvites", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser          User                      @relation("ReceivedInvites", fields: [toUserId], references: [id], onDelete: Cascade)
  challenge       Challenge                 @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  userChallenge   UserChallenge?            @relation(fields: [userChallengeId], references: [id], onDelete: Cascade)

  @@unique([fromUserId, toUserId, challengeId, date])
  @@index([toUserId, status])
  @@index([fromUserId])
  @@index([date])
  @@map("challenge_invitations")
}

/// *
/// * Categorias de desafios disponíveis
/// * Organiza os desafios por área da vida
enum ChallengeCategory {
  PHYSICAL_ACTIVITY
  NUTRITION
  HYDRATION
  MENTAL_HEALTH
  SLEEP
  SOCIAL
  PRODUCTIVITY
}

/// *
/// * Níveis de dificuldade dos desafios
/// * Determina XP e moedas ganhas
enum ChallengeDifficulty {
  EASY
  MEDIUM
  HARD
  EXPERT
}

/// *
/// * Frequência de repetição do desafio
/// * Define como o desafio se repete
enum ChallengeFrequency {
  DAILY
  WEEKLY
  MONTHLY
  ONE_TIME
}

/// *
/// * Status do desafio para o usuário
/// * Rastreia o progresso individual
enum ChallengeStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  SKIPPED
}

/// *
/// * Categorias de badges (emblemas)
/// * Define o tipo/tema do badge
enum BadgeCategory {
  BEGINNER
  CONSISTENCY
  MILESTONE
  SPECIAL
  SEASONAL
  ACHIEVEMENT
  SOCIAL
}

/// *
/// * Tipo de requisito para desbloquear badge
/// * Define qual condição deve ser cumprida
enum BadgeRequirementType {
  CHALLENGES_COMPLETED
  STREAK_DAYS
  LEVEL_REACHED
  XP_EARNED
  SPECIFIC_CHALLENGE
  CATEGORY_MASTER
  SOCIAL_INTERACTION
  EVENT_COUNT
}

/// *
/// * Raridade do badge
/// * Determina o quão difícil é conseguir
enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

/// *
/// * Tipos de recompensas disponíveis
/// * Define o que o usuário ganha
enum RewardType {
  XP
  COINS
  BADGE
  ITEM
}

/// *
/// * Status de solicitação de amizade
/// * Define o estado atual da solicitação
enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
  BLOCKED
}

/// *
/// * Status de convite de desafio
/// * Define o estado atual do convite
enum ChallengeInvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

/// *
/// * Tipos de itens da loja
/// * Define o comportamento do item no sistema
enum ShopItemType {
  COSMETIC   // Não expira, pode equipar/desequipar
  CONSUMABLE // Uso único, decrementa quantidade
  BOOST      // Temporário, cria ActiveBoost
  PACK       // Pacote de múltiplos itens
}

/// *
/// * Raridade dos itens da loja
/// * Define o valor e exclusividade do item
enum ShopItemRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

/// *
/// * Catálogo de Itens da Loja
/// * 
/// * Define todos os itens disponíveis para compra com FiCoins.
/// * Exemplos:
/// * - Moldura dourada para avatar (COSMETIC, EPIC, 250 coins)
/// * - Boost XP +50% 24h (BOOST, RARE, 200 coins)
/// * - Proteção de Streak (CONSUMABLE, LEGENDARY, 400 coins)
model ShopItem {
  id          String         @id @default(uuid())
  sku         String         @unique
  title       String
  description String
  price       Int
  type        ShopItemType
  category    String?
  rarity      ShopItemRarity
  metadata    Json
  imageUrl    String         @map("image_url")
  stock       Int?
  isActive    Boolean        @default(true) @map("is_active")
  isFeatured  Boolean        @default(false) @map("is_featured")
  order       Int            @default(0)
  createdAt   DateTime       @default(now()) @map("created_at")
  updatedAt   DateTime       @updatedAt @map("updated_at")
  purchases   Purchase[]
  inventories UserInventory[]

  @@index([type, isActive])
  @@index([rarity])
  @@index([isFeatured, order])
  @@map("shop_items")
}

/// *
/// * Inventário do Usuário
/// * 
/// * Registra todos os itens que o usuário possui.
/// * Para consumíveis: quantity > 1 (pode empilhar)
/// * Para cosméticos: isEquipped define se está ativo
/// * Para boosts: ao usar, cria ActiveBoost
model UserInventory {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  itemId     String   @map("item_id")
  quantity   Int      @default(1)
  isEquipped Boolean  @default(false) @map("is_equipped")
  metadata   Json?
  acquiredAt DateTime @default(now()) @map("acquired_at")
  lastUsedAt DateTime? @map("last_used_at")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  item       ShopItem @relation(fields: [itemId], references: [id], onDelete: Restrict)

  @@unique([userId, itemId])
  @@index([userId, isEquipped])
  @@map("user_inventory")
}

/// *
/// * Histórico de Compras
/// * 
/// * Registra todas as compras feitas na loja para auditoria.
/// * Salva o preço pago (pode mudar no futuro) e saldo antes/depois.
/// * Imutável - nunca deve ser deletado.
model Purchase {
  id            String   @id @default(uuid())
  userId        String   @map("user_id")
  itemId        String   @map("item_id")
  quantity      Int      @default(1)
  price         Int
  totalCost     Int      @map("total_cost")
  balanceBefore Int      @map("balance_before")
  balanceAfter  Int      @map("balance_after")
  metadata      Json?
  createdAt     DateTime @default(now()) @map("created_at")
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  item          ShopItem @relation(fields: [itemId], references: [id], onDelete: Restrict)

  @@index([userId, createdAt])
  @@index([itemId])
  @@map("purchases")
}

/// *
/// * Boosts Temporários Ativos
/// * 
/// * Registra boosts atualmente ativos do usuário.
/// * Boosts são criados ao usar item do tipo BOOST.
/// * Expiram automaticamente após o período definido.
/// * Exemplos:
/// * - XP +50% por 24h
/// * - Coins +20% por 12h
/// * - Proteção de streak por 1 dia
model ActiveBoost {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  itemSku   String   @map("item_sku")
  type      String
  value     Float
  expiresAt DateTime @map("expires_at")
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive, expiresAt])
  @@map("active_boosts")
}
